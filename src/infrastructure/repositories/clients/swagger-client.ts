/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "http://78.47.21.134:5005";
    }

    admin_AdminRegistration(command: AdminRegistrationCommand): Promise<AdminRegistrationVm> {
        let url_ = this.baseUrl + "/api/Admin/AdminRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAdmin_AdminRegistration(_response);
        });
    }

    protected processAdmin_AdminRegistration(response: AxiosResponse): Promise<AdminRegistrationVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminRegistrationVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdminRegistrationVm>(<any>null);
    }

    admin_SignInAdmin(command: SignInAdminCommand): Promise<SignInVm> {
        let url_ = this.baseUrl + "/api/Admin/SignInAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAdmin_SignInAdmin(_response);
        });
    }

    protected processAdmin_SignInAdmin(response: AxiosResponse): Promise<SignInVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SignInVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SignInVm>(<any>null);
    }

    admin_RestorePassword(command: RestorePasswordCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Admin/RestorePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAdmin_RestorePassword(_response);
        });
    }

    protected processAdmin_RestorePassword(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    admin_Logout(command: LogoutCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Admin/Logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAdmin_Logout(_response);
        });
    }

    protected processAdmin_Logout(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    admin_RefreshToken(command: RefreshTokenCommand): Promise<SignInVm> {
        let url_ = this.baseUrl + "/api/Admin/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAdmin_RefreshToken(_response);
        });
    }

    protected processAdmin_RefreshToken(response: AxiosResponse): Promise<SignInVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SignInVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SignInVm>(<any>null);
    }

    category_GetAllCategories(): Promise<ListCategoriesVm> {
        let url_ = this.baseUrl + "/api/Category/GetAllCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCategory_GetAllCategories(_response);
        });
    }

    protected processCategory_GetAllCategories(response: AxiosResponse): Promise<ListCategoriesVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListCategoriesVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListCategoriesVm>(<any>null);
    }

    category_GetCategoryIcons(): Promise<ListCategoryIconsVm> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryIcons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCategory_GetCategoryIcons(_response);
        });
    }

    protected processCategory_GetCategoryIcons(response: AxiosResponse): Promise<ListCategoryIconsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListCategoryIconsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListCategoryIconsVm>(<any>null);
    }

    category_CreateCategories(command: CreateCategoryCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Category/CreateCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCategory_CreateCategories(_response);
        });
    }

    protected processCategory_CreateCategories(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    category_UpdateCategory(command: UpdateCategoryCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Category/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCategory_UpdateCategory(_response);
        });
    }

    protected processCategory_UpdateCategory(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    category_DeleteCategory(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Category/DeleteCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCategory_DeleteCategory(_response);
        });
    }

    protected processCategory_DeleteCategory(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    group_GetAllGroups(): Promise<ListGroupVm> {
        let url_ = this.baseUrl + "/api/Group/GetAllGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGroup_GetAllGroups(_response);
        });
    }

    protected processGroup_GetAllGroups(response: AxiosResponse): Promise<ListGroupVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListGroupVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListGroupVm>(<any>null);
    }

    group_CreateGroup(command: CreateGroupCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Group/CreateGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGroup_CreateGroup(_response);
        });
    }

    protected processGroup_CreateGroup(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    group_UpdateGroup(command: UpdateGroupCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Group/UpdateGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGroup_UpdateGroup(_response);
        });
    }

    protected processGroup_UpdateGroup(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    group_DeleteGroup(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Group/DeleteGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGroup_DeleteGroup(_response);
        });
    }

    protected processGroup_DeleteGroup(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    organization_GetAllOrganizations(): Promise<ListOrganizationsVm> {
        let url_ = this.baseUrl + "/api/Organization/GetAllOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processOrganization_GetAllOrganizations(_response);
        });
    }

    protected processOrganization_GetAllOrganizations(response: AxiosResponse): Promise<ListOrganizationsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListOrganizationsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListOrganizationsVm>(<any>null);
    }

    region_GetAllRegions(): Promise<ListRegionsVm> {
        let url_ = this.baseUrl + "/api/Region/GetAllRegions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRegion_GetAllRegions(_response);
        });
    }

    protected processRegion_GetAllRegions(response: AxiosResponse): Promise<ListRegionsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListRegionsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListRegionsVm>(<any>null);
    }

    request_GetConfirmedRequests(groupId: number | null | undefined, categoryId: number | null | undefined, cityId: number | null | undefined): Promise<ListRequestsVm> {
        let url_ = this.baseUrl + "/api/Request/GetConfirmedRequests?";
        if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_GetConfirmedRequests(_response);
        });
    }

    protected processRequest_GetConfirmedRequests(response: AxiosResponse): Promise<ListRequestsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListRequestsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListRequestsVm>(<any>null);
    }

    request_GetInWorkVolunteerRequests(groupId: number | null | undefined, categoryId: number | null | undefined, cityId: number | null | undefined): Promise<ListRequestsVm> {
        let url_ = this.baseUrl + "/api/Request/GetInWorkVolunteerRequests?";
        if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_GetInWorkVolunteerRequests(_response);
        });
    }

    protected processRequest_GetInWorkVolunteerRequests(response: AxiosResponse): Promise<ListRequestsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListRequestsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListRequestsVm>(<any>null);
    }

    request_GetCompleteVolunteerRequests(groupId: number | null | undefined, categoryId: number | null | undefined, cityId: number | null | undefined): Promise<ListRequestsVm> {
        let url_ = this.baseUrl + "/api/Request/GetCompleteVolunteerRequests?";
        if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_GetCompleteVolunteerRequests(_response);
        });
    }

    protected processRequest_GetCompleteVolunteerRequests(response: AxiosResponse): Promise<ListRequestsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListRequestsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListRequestsVm>(<any>null);
    }

    request_GetCommentsByIdRequest(id: number | undefined): Promise<ListCommentsVm> {
        let url_ = this.baseUrl + "/api/Request/GetCommentsByIdRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_GetCommentsByIdRequest(_response);
        });
    }

    protected processRequest_GetCommentsByIdRequest(response: AxiosResponse): Promise<ListCommentsVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListCommentsVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListCommentsVm>(<any>null);
    }

    request_CompleteByVolunteer(command: CompleteByVolunteerCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Request/CompleteByVolunteer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_CompleteByVolunteer(_response);
        });
    }

    protected processRequest_CompleteByVolunteer(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    request_ReturnByVolunteer(command: ReturnByVolunteerCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Request/ReturnByVolunteer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_ReturnByVolunteer(_response);
        });
    }

    protected processRequest_ReturnByVolunteer(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    request_TakeInWorkRequest(command: TakeInWorkRequestCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Request/TakeInWorkRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_TakeInWorkRequest(_response);
        });
    }

    protected processRequest_TakeInWorkRequest(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    request_CreateRequest(command: CreateRequestCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Request/CreateRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_CreateRequest(_response);
        });
    }

    protected processRequest_CreateRequest(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    request_UpdateRequest(command: UpdateRequestCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Request/UpdateRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_UpdateRequest(_response);
        });
    }

    protected processRequest_UpdateRequest(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    request_RequestToArchive(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Request/RequestToArchive?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_RequestToArchive(_response);
        });
    }

    protected processRequest_RequestToArchive(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    request_CreateContact(command: CreateContactCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Request/CreateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_CreateContact(_response);
        });
    }

    protected processRequest_CreateContact(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    request_ConfirmRequest(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Request/ConfirmRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_ConfirmRequest(_response);
        });
    }

    protected processRequest_ConfirmRequest(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    request_RejectedRequest(id: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Request/RejectedRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRequest_RejectedRequest(_response);
        });
    }

    protected processRequest_RejectedRequest(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    test_AccessTokenValidate(accessToken: string | null | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/api/Test/AccessTokenValidate?";
        if (accessToken !== undefined)
            url_ += "accessToken=" + encodeURIComponent("" + accessToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_AccessTokenValidate(_response);
        });
    }

    protected processTest_AccessTokenValidate(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(<any>null);
    }

    test_RefreshToken(): Promise<string> {
        let url_ = this.baseUrl + "/api/Test/RefreshTokenGenerate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_RefreshToken(_response);
        });
    }

    protected processTest_RefreshToken(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    test_Authorize(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Test/Authorize";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_Authorize(_response);
        });
    }

    protected processTest_Authorize(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    test_AllowAnonymous(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Test/AllowAnonymous";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_AllowAnonymous(_response);
        });
    }

    protected processTest_AllowAnonymous(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    test_HashPassword(password: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Test/HashPassword?";
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_HashPassword(_response);
        });
    }

    protected processTest_HashPassword(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    test_HashPasswordValidate(hashPassword: string | null | undefined, password: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Test/HashPasswordValidate?";
        if (hashPassword !== undefined)
            url_ += "hashPassword=" + encodeURIComponent("" + hashPassword) + "&";
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_HashPasswordValidate(_response);
        });
    }

    protected processTest_HashPasswordValidate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    test_SaveFile(file: FileParameter | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Test/SaveFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_SaveFile(_response);
        });
    }

    protected processTest_SaveFile(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    test_GetFilesInUploads(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Test/GetFilesInUploads";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_GetFilesInUploads(_response);
        });
    }

    protected processTest_GetFilesInUploads(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }

    test_GetDirectories(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Test/GetDirectories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest_GetDirectories(_response);
        });
    }

    protected processTest_GetDirectories(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }

    upload_CreateUploadFile(command: CreateUploadFileCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Upload/CreateUploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpload_CreateUploadFile(_response);
        });
    }

    protected processUpload_CreateUploadFile(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    volunteer_VolunteerRegistration(command: VolunteerRegistrationCommand): Promise<VolunteerRegistrationVm> {
        let url_ = this.baseUrl + "/api/Volunteer/VolunteerRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processVolunteer_VolunteerRegistration(_response);
        });
    }

    protected processVolunteer_VolunteerRegistration(response: AxiosResponse): Promise<VolunteerRegistrationVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VolunteerRegistrationVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VolunteerRegistrationVm>(<any>null);
    }

    volunteer_SignInVolunteer(command: SignInVolunteerCommand): Promise<SignInVm> {
        let url_ = this.baseUrl + "/api/Volunteer/SignInVolunteer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processVolunteer_SignInVolunteer(_response);
        });
    }

    protected processVolunteer_SignInVolunteer(response: AxiosResponse): Promise<SignInVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SignInVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SignInVm>(<any>null);
    }

    volunteer_RefreshToken(command: RefreshTokenCommand): Promise<SignInVm> {
        let url_ = this.baseUrl + "/api/Volunteer/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processVolunteer_RefreshToken(_response);
        });
    }

    protected processVolunteer_RefreshToken(response: AxiosResponse): Promise<SignInVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SignInVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SignInVm>(<any>null);
    }

    volunteer_RestorePassword(command: RestorePasswordCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Volunteer/RestorePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processVolunteer_RestorePassword(_response);
        });
    }

    protected processVolunteer_RestorePassword(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    volunteer_Logout(command: LogoutCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Volunteer/Logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processVolunteer_Logout(_response);
        });
    }

    protected processVolunteer_Logout(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    volunteer_GetCurrentUserInfoForCard(): Promise<UserInfoVm> {
        let url_ = this.baseUrl + "/api/Volunteer/GetCurrentUserInfoForCard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            validateStatus: () => true,
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processVolunteer_GetCurrentUserInfoForCard(_response);
        });
    }

    protected processVolunteer_GetCurrentUserInfoForCard(response: AxiosResponse): Promise<UserInfoVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserInfoVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserInfoVm>(<any>null);
    }
}

export class AdminRegistrationVm implements IAdminRegistrationVm {
    id?: number;

    constructor(data?: IAdminRegistrationVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdminRegistrationVm {
        data = typeof data === 'object' ? data : {};
        let result = new AdminRegistrationVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IAdminRegistrationVm {
    id?: number;
}

export class UserRegistration implements IUserRegistration {
    firstName?: string;
    lastName?: string;
    patronymic?: string;
    phoneNumber?: string;
    email?: string;
    password?: string;
    organizationId?: number;
    cityId?: number;
    uploadId?: number;

    constructor(data?: IUserRegistration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.patronymic = _data["patronymic"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.organizationId = _data["organizationId"];
            this.cityId = _data["cityId"];
            this.uploadId = _data["uploadId"];
        }
    }

    static fromJS(data: any): UserRegistration {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegistration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["patronymic"] = this.patronymic;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["password"] = this.password;
        data["organizationId"] = this.organizationId;
        data["cityId"] = this.cityId;
        data["uploadId"] = this.uploadId;
        return data;
    }
}

export interface IUserRegistration {
    firstName?: string;
    lastName?: string;
    patronymic?: string;
    phoneNumber?: string;
    email?: string;
    password?: string;
    organizationId?: number;
    cityId?: number;
    uploadId?: number;
}

export class AdminRegistrationCommand extends UserRegistration implements IAdminRegistrationCommand {
    roles?: Roles;

    constructor(data?: IAdminRegistrationCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.roles = _data["roles"];
        }
    }

    static fromJS(data: any): AdminRegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AdminRegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roles"] = this.roles;
        super.toJSON(data);
        return data;
    }
}

export interface IAdminRegistrationCommand extends IUserRegistration {
    roles?: Roles;
}

export enum Roles {
    Volunteer = 0,
    Manager = 1,
    Admin = 2,
}

export class SignInVm implements ISignInVm {
    accessToken?: AccessToken;
    refreshToken?: string;

    constructor(data?: ISignInVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] ? AccessToken.fromJS(_data["accessToken"]) : <any>undefined;
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): SignInVm {
        data = typeof data === 'object' ? data : {};
        let result = new SignInVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>undefined;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ISignInVm {
    accessToken?: AccessToken;
    refreshToken?: string;
}

export class AccessToken implements IAccessToken {
    token?: string;
    expiresIn?: number;

    constructor(data?: IAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.expiresIn = _data["expiresIn"];
        }
    }

    static fromJS(data: any): AccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new AccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expiresIn"] = this.expiresIn;
        return data;
    }
}

export interface IAccessToken {
    token?: string;
    expiresIn?: number;
}

export class SignInUser implements ISignInUser {
    login?: string;
    password?: string;

    constructor(data?: ISignInUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["login"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignInUser {
        data = typeof data === 'object' ? data : {};
        let result = new SignInUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        data["password"] = this.password;
        return data;
    }
}

export interface ISignInUser {
    login?: string;
    password?: string;
}

export class SignInAdminCommand extends SignInUser implements ISignInAdminCommand {

    constructor(data?: ISignInAdminCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SignInAdminCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignInAdminCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISignInAdminCommand extends ISignInUser {
}

export class RestorePasswordCommand implements IRestorePasswordCommand {
    login?: string;

    constructor(data?: IRestorePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["login"];
        }
    }

    static fromJS(data: any): RestorePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RestorePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        return data;
    }
}

export interface IRestorePasswordCommand {
    login?: string;
}

export class LogoutCommand implements ILogoutCommand {
    refreshToken?: string;

    constructor(data?: ILogoutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): LogoutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ILogoutCommand {
    refreshToken?: string;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
    accessToken?: string;
    refreshToken?: string;

    constructor(data?: IRefreshTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenCommand {
    accessToken?: string;
    refreshToken?: string;
}

export class ListCategoriesVm implements IListCategoriesVm {
    categories?: CategoryDto[];

    constructor(data?: IListCategoriesVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListCategoriesVm {
        data = typeof data === 'object' ? data : {};
        let result = new ListCategoriesVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListCategoriesVm {
    categories?: CategoryDto[];
}

export class CategoryDto implements ICategoryDto {
    id?: number;
    name?: string;
    iconKey?: string;
    uploadId?: number;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.iconKey = _data["iconKey"];
            this.uploadId = _data["uploadId"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["iconKey"] = this.iconKey;
        data["uploadId"] = this.uploadId;
        return data;
    }
}

export interface ICategoryDto {
    id?: number;
    name?: string;
    iconKey?: string;
    uploadId?: number;
}

export class ListCategoryIconsVm implements IListCategoryIconsVm {
    categoryIcons?: CategoryIconDto[];

    constructor(data?: IListCategoryIconsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categoryIcons"])) {
                this.categoryIcons = [] as any;
                for (let item of _data["categoryIcons"])
                    this.categoryIcons!.push(CategoryIconDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListCategoryIconsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ListCategoryIconsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categoryIcons)) {
            data["categoryIcons"] = [];
            for (let item of this.categoryIcons)
                data["categoryIcons"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListCategoryIconsVm {
    categoryIcons?: CategoryIconDto[];
}

export class CategoryIconDto implements ICategoryIconDto {
    id?: number;
    iconKey?: string;
    description?: string;

    constructor(data?: ICategoryIconDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.iconKey = _data["iconKey"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CategoryIconDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryIconDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["iconKey"] = this.iconKey;
        data["description"] = this.description;
        return data;
    }
}

export interface ICategoryIconDto {
    id?: number;
    iconKey?: string;
    description?: string;
}

export class CategoryRequest implements ICategoryRequest {
    name?: string;
    uploadId?: number;
    iconId?: number;

    constructor(data?: ICategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.uploadId = _data["uploadId"];
            this.iconId = _data["iconId"];
        }
    }

    static fromJS(data: any): CategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["uploadId"] = this.uploadId;
        data["iconId"] = this.iconId;
        return data;
    }
}

export interface ICategoryRequest {
    name?: string;
    uploadId?: number;
    iconId?: number;
}

export class CreateCategoryCommand extends CategoryRequest implements ICreateCategoryCommand {

    constructor(data?: ICreateCategoryCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateCategoryCommand extends ICategoryRequest {
}

export class UpdateCategoryCommand extends CategoryRequest implements IUpdateCategoryCommand {
    id?: number;

    constructor(data?: IUpdateCategoryCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateCategoryCommand extends ICategoryRequest {
    id?: number;
}

export class ListGroupVm implements IListGroupVm {
    groups?: GroupDto[];

    constructor(data?: IListGroupVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListGroupVm {
        data = typeof data === 'object' ? data : {};
        let result = new ListGroupVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListGroupVm {
    groups?: GroupDto[];
}

export class GroupDto implements IGroupDto {
    id?: number;
    name?: string;
    uploadId?: number;

    constructor(data?: IGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.uploadId = _data["uploadId"];
        }
    }

    static fromJS(data: any): GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["uploadId"] = this.uploadId;
        return data;
    }
}

export interface IGroupDto {
    id?: number;
    name?: string;
    uploadId?: number;
}

export class GroupRequest implements IGroupRequest {
    name?: string;
    uploadId?: number;

    constructor(data?: IGroupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.uploadId = _data["uploadId"];
        }
    }

    static fromJS(data: any): GroupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GroupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["uploadId"] = this.uploadId;
        return data;
    }
}

export interface IGroupRequest {
    name?: string;
    uploadId?: number;
}

export class CreateGroupCommand extends GroupRequest implements ICreateGroupCommand {

    constructor(data?: ICreateGroupCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateGroupCommand extends IGroupRequest {
}

export class UpdateGroupCommand extends GroupRequest implements IUpdateGroupCommand {
    id?: number;

    constructor(data?: IUpdateGroupCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateGroupCommand extends IGroupRequest {
    id?: number;
}

export class ListOrganizationsVm implements IListOrganizationsVm {
    organizations?: OrganizationDto[];

    constructor(data?: IListOrganizationsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(OrganizationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOrganizationsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ListOrganizationsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListOrganizationsVm {
    organizations?: OrganizationDto[];
}

export class OrganizationDto implements IOrganizationDto {
    id?: number;
    name?: string;

    constructor(data?: IOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IOrganizationDto {
    id?: number;
    name?: string;
}

export class ListRegionsVm implements IListRegionsVm {
    regions?: RegionDto[];

    constructor(data?: IListRegionsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["regions"])) {
                this.regions = [] as any;
                for (let item of _data["regions"])
                    this.regions!.push(RegionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListRegionsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ListRegionsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.regions)) {
            data["regions"] = [];
            for (let item of this.regions)
                data["regions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListRegionsVm {
    regions?: RegionDto[];
}

export class RegionDto implements IRegionDto {
    id?: number;
    name?: string;
    cities?: CityDto[];

    constructor(data?: IRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(CityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegionDto {
    id?: number;
    name?: string;
    cities?: CityDto[];
}

export class CityDto implements ICityDto {
    id?: number;
    regionId?: number;
    name?: string;

    constructor(data?: ICityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.regionId = _data["regionId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["regionId"] = this.regionId;
        data["name"] = this.name;
        return data;
    }
}

export interface ICityDto {
    id?: number;
    regionId?: number;
    name?: string;
}

export class ListRequestsVm implements IListRequestsVm {
    requests?: RequestDto[];

    constructor(data?: IListRequestsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests!.push(RequestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListRequestsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ListRequestsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListRequestsVm {
    requests?: RequestDto[];
}

export class RequestDto implements IRequestDto {
    id?: number;
    categoryName?: string;
    iconKey?: string;
    description?: string;
    completionDate?: Date;
    phoneNumber?: string;
    contactFullName?: string;
    address?: string;
    status?: StatusRequest;

    constructor(data?: IRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryName = _data["categoryName"];
            this.iconKey = _data["iconKey"];
            this.description = _data["description"];
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.contactFullName = _data["contactFullName"];
            this.address = _data["address"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        data["iconKey"] = this.iconKey;
        data["description"] = this.description;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["contactFullName"] = this.contactFullName;
        data["address"] = this.address;
        data["status"] = this.status;
        return data;
    }
}

export interface IRequestDto {
    id?: number;
    categoryName?: string;
    iconKey?: string;
    description?: string;
    completionDate?: Date;
    phoneNumber?: string;
    contactFullName?: string;
    address?: string;
    status?: StatusRequest;
}

export enum StatusRequest {
    New = 0,
    Rejected = 1,
    Confirmed = 2,
    InWork = 3,
    ReturnedByVolunteer = 4,
    Complete = 5,
    Deleted = 6,
}

export class ListCommentsVm implements IListCommentsVm {
    comments?: CommentDto[];

    constructor(data?: IListCommentsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListCommentsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ListCommentsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListCommentsVm {
    comments?: CommentDto[];
}

export class CommentDto implements ICommentDto {
    name?: string;
    message?: string;
    created?: Date;
    status?: CommentStatus;
    uploads?: number[];

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.message = _data["message"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["uploads"])) {
                this.uploads = [] as any;
                for (let item of _data["uploads"])
                    this.uploads!.push(item);
            }
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["message"] = this.message;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.uploads)) {
            data["uploads"] = [];
            for (let item of this.uploads)
                data["uploads"].push(item);
        }
        return data;
    }
}

export interface ICommentDto {
    name?: string;
    message?: string;
    created?: Date;
    status?: CommentStatus;
    uploads?: number[];
}

export enum CommentStatus {
    Reject = 0,
    Complete = 1,
    Comment = 2,
}

export class CompleteByVolunteerCommand implements ICompleteByVolunteerCommand {
    requestId?: number;
    message?: string;
    uploadIds?: number[];

    constructor(data?: ICompleteByVolunteerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.message = _data["message"];
            if (Array.isArray(_data["uploadIds"])) {
                this.uploadIds = [] as any;
                for (let item of _data["uploadIds"])
                    this.uploadIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CompleteByVolunteerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteByVolunteerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["message"] = this.message;
        if (Array.isArray(this.uploadIds)) {
            data["uploadIds"] = [];
            for (let item of this.uploadIds)
                data["uploadIds"].push(item);
        }
        return data;
    }
}

export interface ICompleteByVolunteerCommand {
    requestId?: number;
    message?: string;
    uploadIds?: number[];
}

export class ReturnByVolunteerCommand implements IReturnByVolunteerCommand {
    requestId?: number;
    message?: string;

    constructor(data?: IReturnByVolunteerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ReturnByVolunteerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnByVolunteerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["message"] = this.message;
        return data;
    }
}

export interface IReturnByVolunteerCommand {
    requestId?: number;
    message?: string;
}

export class TakeInWorkRequestCommand implements ITakeInWorkRequestCommand {
    requestId?: number;

    constructor(data?: ITakeInWorkRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): TakeInWorkRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TakeInWorkRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        return data;
    }
}

export interface ITakeInWorkRequestCommand {
    requestId?: number;
}

export class RequestRequest implements IRequestRequest {
    contactId?: number;
    completionDate?: Date;
    groupId?: number;
    categoryId?: number;
    description?: string;
    organizationId?: number;

    constructor(data?: IRequestRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.groupId = _data["groupId"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            this.organizationId = _data["organizationId"];
        }
    }

    static fromJS(data: any): RequestRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["groupId"] = this.groupId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["organizationId"] = this.organizationId;
        return data;
    }
}

export interface IRequestRequest {
    contactId?: number;
    completionDate?: Date;
    groupId?: number;
    categoryId?: number;
    description?: string;
    organizationId?: number;
}

export class CreateRequestCommand extends RequestRequest implements ICreateRequestCommand {

    constructor(data?: ICreateRequestCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateRequestCommand extends IRequestRequest {
}

export class UpdateRequestCommand extends RequestRequest implements IUpdateRequestCommand {
    id?: number;

    constructor(data?: IUpdateRequestCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateRequestCommand extends IRequestRequest {
    id?: number;
}

export class ContactRequest implements IContactRequest {
    cityId?: number;
    street?: string;
    house?: number | undefined;
    flat?: number | undefined;
    firstName?: string;
    lastName?: string;
    patronymic?: string;
    phoneNumber?: string;

    constructor(data?: IContactRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cityId = _data["cityId"];
            this.street = _data["street"];
            this.house = _data["house"];
            this.flat = _data["flat"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.patronymic = _data["patronymic"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): ContactRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContactRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId;
        data["street"] = this.street;
        data["house"] = this.house;
        data["flat"] = this.flat;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["patronymic"] = this.patronymic;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IContactRequest {
    cityId?: number;
    street?: string;
    house?: number | undefined;
    flat?: number | undefined;
    firstName?: string;
    lastName?: string;
    patronymic?: string;
    phoneNumber?: string;
}

export class CreateContactCommand extends ContactRequest implements ICreateContactCommand {

    constructor(data?: ICreateContactCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateContactCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateContactCommand extends IContactRequest {
}

export class CreateUploadFileCommand implements ICreateUploadFileCommand {
    fileName?: string;
    contentType?: string;
    file?: string;

    constructor(data?: ICreateUploadFileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): CreateUploadFileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUploadFileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["file"] = this.file;
        return data;
    }
}

export interface ICreateUploadFileCommand {
    fileName?: string;
    contentType?: string;
    file?: string;
}

export class VolunteerRegistrationVm implements IVolunteerRegistrationVm {
    id?: number;
    accessToken?: AccessToken;
    refreshToken?: string;

    constructor(data?: IVolunteerRegistrationVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accessToken = _data["accessToken"] ? AccessToken.fromJS(_data["accessToken"]) : <any>undefined;
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): VolunteerRegistrationVm {
        data = typeof data === 'object' ? data : {};
        let result = new VolunteerRegistrationVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>undefined;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IVolunteerRegistrationVm {
    id?: number;
    accessToken?: AccessToken;
    refreshToken?: string;
}

export class VolunteerRegistrationCommand extends UserRegistration implements IVolunteerRegistrationCommand {

    constructor(data?: IVolunteerRegistrationCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): VolunteerRegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new VolunteerRegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IVolunteerRegistrationCommand extends IUserRegistration {
}

export class SignInVolunteerCommand extends SignInUser implements ISignInVolunteerCommand {

    constructor(data?: ISignInVolunteerCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SignInVolunteerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignInVolunteerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISignInVolunteerCommand extends ISignInUser {
}

export class UserInfoVm implements IUserInfoVm {
    user?: UserInfoDto;

    constructor(data?: IUserInfoVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserInfoDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserInfoVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserInfoVm {
    user?: UserInfoDto;
}

export class UserInfoDto implements IUserInfoDto {
    id?: number;
    firstName?: string;
    lastName?: string;
    patronymic?: string;
    organization?: string;
    phoneNumber?: string;
    email?: string;
    region?: string;
    city?: string;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.patronymic = _data["patronymic"];
            this.organization = _data["organization"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.region = _data["region"];
            this.city = _data["city"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["patronymic"] = this.patronymic;
        data["organization"] = this.organization;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["region"] = this.region;
        data["city"] = this.city;
        return data;
    }
}

export interface IUserInfoDto {
    id?: number;
    firstName?: string;
    lastName?: string;
    patronymic?: string;
    organization?: string;
    phoneNumber?: string;
    email?: string;
    region?: string;
    city?: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
